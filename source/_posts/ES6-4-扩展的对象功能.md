---
title: ES6-4-扩展的对象功能
date: 2019-10-14 13:40:24
tags: ES6
categories: ES6
---
## 对象类别
1.普通对象 

2.奇异对象

3.标准对象

4.内置对象


## 对象字面量的扩展语法
### 属性初始化器
当对象的一个属性名称与本地变量名相同，可省略
```
function person(name,age){
    return {
        name,
        age
    }
}
```
### 新的方法
```
Object.is(a,b) // 此方法可用来比较2个值是否相等  相当于 '==='  不过可以正确比较 NaN === NaN 与 +0 === -0
```

```
Object.assign(<接受对象>,<...供应者对象>);//对象的浅拷贝 
//常见混入（mixin）组合对象
```
PS：
    1.使用Object.assign()后面的供应者对象会覆盖接受对象，后输入的供应者对象会覆盖前面的供应者对象
    2.操作访问器属性时：当未在接受着上创建访问器属性时（即供应者有访问器属性）供应者的访问器属性会变成接受者的数据属性

Object.getOwnPropertyDescriptor(<访问的对象>,<自有属性>);//获取自由属性的描述符（即值、是否可读、是否可写、是否可配置）

## 重复的对象字面量属性
ES5的严格模式，重复的对象属性会报语法错误，ES6移除了这种错误，排在后面的属性的值会成为该属性的值

## 自有属性的枚举顺序
es6中枚举的顺序  数字 字符串 字符 

## 更强大的原型

### 修改对象的原型
对象的原型会在通过构造器或者Objece.create()方法创建时被指定，原型初始化完成后就保存不变
es5中通过Objece.getPrototypeOf(<需要查的对象>) 方法来获取对象中的原型 

es5中没有修改原型的方法，因此es6中定义了修改原型的方法 Object.setPrototypeof(<被修改对象>,<成为原型的对象>);

```
let Person = {
    say(){
        return 'hello';
    }
}

let Dog = {
    say(){
        return 'wang wang';
    }
}

let friend = Object.create(person);//传入Person作为friend的原型
Object.getPrototypeOf(friend) === Person //true 此处原型为Person
friend.say() ;// hello

//将原型设置为dog
Object.setPrototypeOf(friend,Dog);
Object.getPrototypeOf(friend) === Dog //true

friend.say() ;// wang wnag
```

### 使用suer引用的简单原型访问
如果需要覆盖对象实例上的一个方法，但是依然需要调用原型上的同名方法
```
let person = {
    say(){
        return 'hi'
    }
}

let dog = {
    say(){
        return 'wang wang';
    }
}

let friend = {
    say(){
        //此处this指向friend  下面将原型设置为person使用call 将原型的person的方法在此处调用，并且处理下
        return Object.getPrototypeOf(this).say().call(this) + 'hello';
    }
}

Object.setPrototypeOf(friend,person);

```
super 就是指向当前对象原型的一直指针 可以使用super简化

```
let friend = {
    say(){
        return super.say()+' hello';
    }
}
```
PS:super 只适用于简写函数中,下图是错误的用法
```
let friend = {
    say:function(){
        //此处会报语法错误
        return super.say()+' hello';
    }
}
```

当使用多级继承时，如果不使用super就会出问题，因为Object.getPrototypeOf(this)总是指向上一级，并不能指向最初的但是使用super就没有这样的问题

