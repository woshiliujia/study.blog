---
title: 你不知道的JS（上）-作用域和闭包
date: 2019-11-11 10:25:48
tags: JavaScript
categories: JavaScript
---
# 作用域是什么
## 编译原理
JavaScript引擎进行编译与传统语言的编译的步骤相似

1. 分词/词法的分析
    将有意义的代码分解成词法单元。如将 var a = 2;分解成  var、 a、 =、 2、;

2. 解析/语法分析
    将词法单元(数组)转换成一个有元素逐级嵌套所组成的程序语法解构树，称为抽象语法树(AST)

3. 代码生成
    将AST转换成可执行代码。具体细节就不深入了，不会。


## 理解作用域
引擎：负责整个编译执行过程
编译器：负责语法分析与代码生成
作用域：维护变量规则，确定执行代码的时候对标识符的访问权限

LHS:赋值操作的左侧，表示查找到某个变量所在的位置，不关注它的值 例：a = 2; 等号左侧主要想要找到a的位置，因此左侧是LHS
RHS:赋值操作的右侧，表示查找到某个变量的值，不关注它的位置 例：a = 2;等号右侧是想将a的值设置为2，因此找到原值，将其替换


## 作用域的嵌套
当一个块或函数嵌套在另一个块或函数中就发生了作用域嵌套
遍历作用域的规则：从当前作用域开始查找，如果找不到就到上一级作用域直到全局作用域。

## 异常  RHS 与 LHS的错误捕获
```
function foo(a){
    console.log(a + b);
}
foo(2);
```
以上例子中执行到 'console.log(a + b)';查找b是个RHS操作（即只关心b的值），但是先会在foo函数作用域内查找是否有变量b，没有再去全局作用域中查找。也没查到的话会抛出ReferenceError 引用错误。
因此当进行RHS操作时，如果失败就会报引用错误

LHS：当执行LHS操作时，如果在全局作用域中都未找到此变量并且在非严格模式中，全局作用域会创建一个此名称的变量，并返还给引擎。如果在严格模式中则会抛出相似的引用错误

## 小结
作用域是一套规则。用于在何处以及如何查找变量。
如果查找的目的是对变量进行赋值则就会使用LHS查询
如果目的是获取目标的值则就会使用RHS查询

# 词法作用域

## 词法阶段
词法作用域 不管函数在哪里被调用，无论如何被调用词法作用域只由声明时所处的位置决定
作用域的查找：作用域的查找会在找到第一个匹配的标识符后停止。多层的嵌套作用域中可以定义同名的标识符，这叫遮蔽效应。

## 欺骗词法
### eval with
```
function foo(str,a){
    eval(str);//此处会运行时的词法作用域，严格模式中会报错
    console.log(str,b);//输出1，3
}
var b = 2;
foo('var b = 3',1)
```

### 性能
大量使用eval与with会使代码运行更慢，没有优化可言。 不要使用这两个欺骗作用域的方法 因此我也就不看了


# 函数作用域和块作用域

区分函数声明和表达式最简单的方法就是看 function 关键字出现在声明中的位置 如果funtion是声明中的第一个词，则就是函数声明，否则就是表达式
因此匿名函数实则是函数表达式

### IIFE 立即执行函数表达式

## 块作用域

## 垃圾收集
显示声明块作用域，并对本地变量进行绑定，可以有效触发Javascript的垃圾回收机制
```
//可能不触发回收机制的代码
function procss(){
    //...
}
var someReallyBigData = {};
procss(someReallyBigData);

var btn = document.getElementById('my-btn');
btn.addEventListener('click',function(e){
    console.log('click');
})
//由于click函数形成了覆盖整个作用域的闭包，因此JavaScript引擎可能依旧保存此解构 并不会回收someReallyBigData()
```



# 提升
JavaScript中会早上变量的声明被提升  var 与 函数函数的声明

函数的声明的优先级要大过var的定义 即相同变量的定义，函数的优先级始终高于var的定义

不要在条件判断中使用函数的声明


# 作用域闭包

无论通过什么手段将内部函数传递到所在词法作用域之外，它都会保持对原始作用域的引用，无论在何处执行这个函数都会使用闭包

回调函数实际就是闭包
